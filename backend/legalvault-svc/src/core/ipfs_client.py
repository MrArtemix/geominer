"""
Placeholder IPFS client for LegalVault.

Since a real IPFS node is not included in the Docker Compose setup, this
module generates deterministic CID-like strings from SHA-256 hashes.
The generated strings are prefixed with "bafy" to mimic IPFS CIDv1 format.

TODO: Real IPFS integration
-------------------------------
When a real IPFS node (e.g. Kubo / go-ipfs) is added to Docker Compose:

1. Replace generate_cid() with an actual `ipfs add` call via the IPFS
   HTTP API (default: http://ipfs:5001/api/v0/add).

2. Use the httpx library (already in requirements.txt) to POST the file
   bytes to the IPFS API and extract the real CID from the JSON response.

3. For retrieval, use the IPFS gateway (http://ipfs:8080/ipfs/<CID>) or
   the API endpoint /api/v0/cat?arg=<CID>.

4. Consider pinning important evidence files so they are not garbage-
   collected: POST /api/v0/pin/add?arg=<CID>.

Example future implementation:
    import httpx

    IPFS_API_URL = "http://ipfs:5001/api/v0"

    async def add_to_ipfs(data: bytes, filename: str) -> str:
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{IPFS_API_URL}/add",
                files={"file": (filename, data)},
            )
            response.raise_for_status()
            return response.json()["Hash"]  # This is the real CID
"""

import hashlib
import base64


def generate_cid(sha256_hex: str) -> str:
    """
    Generate a deterministic IPFS-CIDv1-like string from a SHA-256 hex digest.

    The real CIDv1 is a multibase + multicodec + multihash encoding.  Here we
    approximate the visual format by:

    1. Taking the raw SHA-256 bytes (from the hex digest).
    2. Base32-encoding them (lowercase, no padding) -- the encoding used by
       CIDv1 in base32.
    3. Prefixing with "bafy" to mimic the typical CIDv1 prefix for
       dag-pb + sha2-256 content.

    This is NOT a valid CID, but it is deterministic and visually similar.

    Args:
        sha256_hex: Hex-encoded SHA-256 hash string.

    Returns:
        A string that looks like "bafyrei..." (deterministic, ~60 chars).
    """
    raw_bytes = bytes.fromhex(sha256_hex)

    # Base32-encode (lowercase, strip padding)
    b32 = base64.b32encode(raw_bytes).decode("ascii").lower().rstrip("=")

    # Prefix to mimic CIDv1 (bafy = base32 + dag-pb + sha256 in real CID)
    return f"bafy{b32}"


def cid_to_sha256(cid: str) -> str:
    """
    Reverse the simulated CID back to its SHA-256 hex digest.

    Only works with CIDs generated by generate_cid() above.

    Args:
        cid: The simulated CID string.

    Returns:
        The original SHA-256 hex digest.
    """
    b32_part = cid[4:]  # Strip "bafy" prefix

    # Re-add base32 padding
    padding = (8 - len(b32_part) % 8) % 8
    b32_padded = b32_part.upper() + "=" * padding

    raw_bytes = base64.b32decode(b32_padded)
    return raw_bytes.hex()
